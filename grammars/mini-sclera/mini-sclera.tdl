;;; -*- Mode: TDL; Coding: utf-8 -*-

;; head types

complex-picto := head.
complex-subj+vp-picto := complex-picto & verb.
complex-vp-picto := complex-picto & verb.

; complex-picto :+ [ SCLERA sclera-hooks ].
; sclera-hooks := avm &
;  [ N1 ref-ind,
;    N2 ref-ind,
;    V1 event,
;    V2 event ].

;;; complex S-V pictos

;; experiment 1:

cat :+ [ COMPLEX bool ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; lexical types

main-complex-v-picto-lex := lex-item &
  [ SYNSEM.LOCAL [ CAT [ VAL  [ SPR < >,
                                SPEC < >,
                                COMPS < > ],
                         COMPLEX + ] ] ].
    ; SYNSEM.LKEYS.KEYREL event-relation ].

; e.g. "brush_dog"
; Rest is taken care of by subject-head rule
complex-vp-picto-lex := main-complex-v-picto-lex &
  [ SYNSEM.LOCAL [ CAT  [ HEAD complex-vp-picto,
                          VAL.SUBJ < #subject > ],
                   CONT [ HOOK [ LTOP #lbl_head,
                                 INDEX #event,
                                 XARG  #xarg-subj ], ; optional
                          RELS.LIST.FIRST [ LBL #lbl_head,
                                            ARG0 event & #event,
                                            ARG1 #xarg-subj ] ] ],
    ARG-ST.FIRST #subject &
                 [ LOCAL [ CAT [ HEAD noun,
                                 VAL [ SPR < >,
                                       COMPS < > ] ],
                           CONT.HOOK.INDEX #xarg-subj ] ] ].

; e.g. "dog_bark"
complex-subj+vp-picto-lex := main-complex-v-picto-lex &
  [ SYNSEM.LOCAL [ CAT  [ HEAD complex-subj+vp-picto,
                          VAL.SUBJ < > ],
                   CONT [ HOOK [ LTOP #lbl_head,
                                 INDEX #event],
                          RELS.LIST.FIRST [ ARG0 event & #event,
                                            LBL #lbl_head ] ] ] ].

; complex-subj+vp-picto-lex :+ "all-in-one cannonball of expression".

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; rules

; e.g. "dog_bark" -> "the dog barks"
complex-subj+vp-picto-rule := head-only &
  [ SYNSEM.LOCAL.CAT [ HEAD verb,
                       VAL [ SPR < >,
			                 SUBJ < >,
			                 COMPS < >,
			                 SPEC < > ],
                       COMPLEX - ],
    SYNSEM.LOCAL.CONT.HOOK #hook,
    HEAD-DTR lex-item &
        [ SYNSEM.LOCAL [ CONT.HOOK #hook,
                         CAT [ HEAD complex-subj+vp-picto,
    				           VAL [ SPR < >,
    					             SUBJ < >,
    					             COMPS < > ],
                               COMPLEX + ] ] ] ].

; based on basic-bare-np-phrase (matrix.tdl, 2055)
; e.g. { dog_n_rel(x) } => { DET(d, x) dog_n_rel(x)}
sclera-basic-insert-definite-det-rule := head-only &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
			   SUBJ < >,
			   COMPS < >,
			   SPEC < > ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun,
				  VAL [ SPR < [ LOCAL.CAT.HEAD det,
						OPT - ] >,
					SUBJ < >,
					COMPS < > ] ],
			    CONT.HOOK [ INDEX #index,
					        LTOP #larg ] ],
    C-CONT [ RELS <! quant-relation &
              [ PRED "q_rel_min",
		        ARG0 #index,
		        RSTR #harg ] !>,
	         HCONS <! qeq &
		      [ HARG #harg,
		        LARG #larg ] !>,
	         ICONS <! !>,
	         HOOK [ INDEX #index ] ] ].

sclera-bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS <! [ PRED "exist_q_rel" ] !> ].

; experiment with open-ended lists: < ... >
; experiment with dotted pair list: < a, b . rest >
; delete

; hook :+ [ SCLERA sclera-hooks ].
; sclera-hooks := avm &
;  [ N1 ref-ind,
;    N2 ref-ind,
;    V1 event,
;    V2 event ].

; some-test-start := phrase &
;   [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
;                            COMPS < > ],
;     SYNSEM.LOCAL.CONT [ TEMP-RELS-REST #rels ],
;     ARGS < [ SYNSEM.LOCAL.CONT.RELS.LIST #rels ] > ].
;
; some-test-loop := phrase &
;   [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
;                            COMPS < > ],
;     SYNSEM.LOCAL.CONT [ TEMP-RELS-FIRST #first,
;                         TEMP-RELS-REST #rest ],
;     ARGS < [ SYNSEM.LOCAL.CONT.TEMP-RELS-REST [ FIRST #first,
;                                                 REST  #rest & cons ] ] > ].

; some-test-loop := phrase &
;   [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
;                            COMPS < > ],
;     SYNSEM.LOCAL.CONT [ TEMP-REL #first,
;                         RELS [ LIST #rest,
;                                LAST #last ] ],
;     ARGS < [ SYNSEM.LOCAL.CONT.RELS [ LIST [ FIRST #first,
;                                              REST  #rest ],
;                                       LAST #last ] ] > ].

                                    ;   LAST  ] ] > ].

; check-noun :=
;   [ ARGS < [] > ].

; test-picto := lex-item &
;   [ SYNSEM.LOCAL.CAT.HEAD complex-picto,
;     SYNSEM.LOCAL.CONT.RELS <! "a", "b", "c" !> ].
